\ boot.ok - Bootstrapping PropulsionScript on the okami engine.
\ Copyright (C) 2018, 2022 Wolfgang JÃ¤hrling
\
\ ISC License
\
\ Permission to use, copy, modify, and/or distribute this software for any
\ purpose with or without fee is hereby granted, provided that the above
\ copyright notice and this permission notice appear in all copies.
\
\ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
\ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
\ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
\ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
\ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
\ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
\ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

\     "An adequate bootstrap is a contradiction in terms."
\         -- Alan Perlis

\ We start in a very restricted environment, so setting up the system
\ is a bit of work. In fact, this file needs to be preprocessed before
\ it is fed into the okami engine. The preprocessing involves five
\ aspects:
\
\ 1. replace constants with values depending on OS/arch
\    (This is done by the okcc.sh shell script. The other steps are
\    performed by ppok.)
\ 2. remove the backlashed comments
\ 3. transform [compile] and [[postpone]] stuff into rudimentary form
\ 4. place each word into a machine-word (8 byte), padding with spaces
\ 5. convert #numbers into code that generates them
\
\ We get the address of the dataspace on the stack initially, so we
\ duplicate it for later use when we are going to to calculate the end
\ of the dataspace where we will store our dictionary later.
\ Initially, we use the simple builtin dictionary that only supports
\ word names up to 8 bytes.

this

\ We don't want to keep the here pointer on the stack all the time, so
\ let's create a variable for it:

entry: hp
  ' dopush     that ! cell +
  this cell +  that ! drop

\ the phrase "that ! cell +" corresponds to "," - except that it uses
\ the TOS (top of stack) instead of a variable, which we obviously do
\ not yet have available at this point, as we are just defining it.
\ The word "entry:" uses the TOS as well, as it also can not rely on
\ a builtin here pointer.
\
\ From now on, we will use the "hp" variable instead of the value on
\ the stack, that's why we dropped the latter in the end above.
\
\ The preprocessing will turn [foo] into "' foo ," (and [[foo]] into
\ "' lit , ' foo , ' , ,"). But before we can start using it, we need
\ to define ",".  This time, we have to replace "," with a snippet that
\ involves using the variable "hp", so that it is properly updated.
\ Note that this phrase - "hp @ !  cell hp @ + hp !" - is the same as
\ the code for "," itself!

hp @ entry: , drop
  ' docol hp @ !  cell hp @ + hp !
  ' hp    hp @ !  cell hp @ + hp !
  ' @     hp @ !  cell hp @ + hp !
  ' !     hp @ !  cell hp @ + hp !
  ' cell  hp @ !  cell hp @ + hp !
  ' hp    hp @ !  cell hp @ + hp !
  ' @     hp @ !  cell hp @ + hp !
  ' +     hp @ !  cell hp @ + hp !
  ' hp    hp @ !  cell hp @ + hp !
  ' !     hp @ !  cell hp @ + hp !
  ' exit  hp @ !  cell hp @ + hp !

\ Now things get almost convenient. Let's allow us to create colon
\ definitions ending in a semicolon from here on:

hp @ entry: : drop
  ' docol ,
  [hp @ entry: drop  lit docol ,  exit]
: ; [[exit] exit]

\ TODO: remove this debugging helper
: dbg [cell >aux auxdrop exit]

\ Of course, these are preliminary definitions, because we will have
\ a more flexible dictionary later that is not based on "entry:" and
\ that allows us to show backtraces and won't limit names to 8 bytes.
\
\ We will often need the value of the here pointer, so define it now.
\ This is an easy one, and in fact our first line that we would always
\ write exactly like this (see how far we have come!):

: here [hp @];

\ We can use this to define some helpers for the control structures.
\ These allow us to leave a branch target open until we know its
\ actual target address. Note that "mark" only calls "cell" to create
\ a dummy value that will be overwritten later.

: mark    [here cell ,];
: resolve [here alt !];

\ Now it's simple to define "if" and friends:

: if   [[branch0] mark];
: end  [resolve];
: else [[branch] mark alt resolve];

: loop   [here];
: while  [[branch0] mark];
: repeat [[branch] alt , resolve];
: until  [[branch0] ,];

: create: [here entry: drop [dopush]];
: with    [[here entry: drop   lit dodoes ,   lit] mark [,]];
: does    [[exit] resolve];

: const: with [,] does [@];
: var:   [create: ,];

#7 const: seven
#0 #1 - const: true

true var: done?

: done [done? @ not] if [cell] else [seven] end ;
done
#0 this this this this
{sys/syscall:SYS_exit}
syscall
